#!/usr/bin/env python3
import math
from re import finditer
from sys import stdin

# 0-based index
DST_X, DST_Y = tuple(int(v) - 1 for v in input().split())

# `world[y][x]` 이렇게 접근해야함
WORLD = [
    [int(tile) for tile in x.group(0)]
    for x in finditer('[01]+', stdin.read())
]
WIDTH = len(WORLD[0])
HEIGHT = len(WORLD)
assert len({len(row) for row in WORLD}) == 1

VISITED = [[False]*WIDTH for _ in range(HEIGHT)]
COST = [[math.inf]*WIDTH for _ in range(HEIGHT)]

# 좌표 하나를 입력하면, 거기에 인접한 인근 좌표들을 반환하는 함수
def enumerate_adjacent_unvisited(position: tuple):
    x, y = position
    assert 0 <= x < WIDTH and 0 <= y < HEIGHT
    if y != 0:
        yield x, y - 1
    if x != 0:
        yield x - 1, y
    if x != WIDTH - 1:
        yield x + 1, y
    if y != HEIGHT - 1:
        yield x, y + 1

# Dijkstra
def enumerate_unvisited():
    for y in range(HEIGHT):
        for x in range(WIDTH):
            if VISITED[y][x]:
                continue
            yield (x, y), COST[y][x]

COST[0][0] = 0
next_coord_cost = ((0, 0), 0)
while True:
    (x0, y0), cost = next_coord_cost
    VISITED[y0][x0] = True

    for x, y in enumerate_adjacent_unvisited((x0, y0)):
        new_cost = cost + WORLD[y][x]
        if COST[y][x] > new_cost:
            COST[y][x] = new_cost

    # TODO: pq로 최적화 할 수 있음
    next_coord_cost = min(enumerate_unvisited(), key=lambda t: t[1])

    if next_coord_cost[0] == (DST_X, DST_Y):
        break

print(COST[DST_Y][DST_X])
# TODO: assert 끄기
